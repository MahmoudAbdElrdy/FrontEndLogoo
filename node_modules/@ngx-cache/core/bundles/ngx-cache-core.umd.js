(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('events')) :
    typeof define === 'function' && define.amd ? define('@ngx-cache/core', ['exports', '@angular/core', 'rxjs', 'rxjs/operators', 'events'], factory) :
    (factory((global['ngx-cache'] = global['ngx-cache'] || {}, global['ngx-cache'].core = {}),global.ng.core,global.rxjs,global.rxjs.operators,global.events));
}(this, (function (exports,core,rxjs,operators,events) { 'use strict';

    var CacheLoader = (function () {
        function CacheLoader() {
        }
        return CacheLoader;
    }());
    var CacheStaticLoader = (function () {
        function CacheStaticLoader(providedSettings) {
            if (providedSettings === void 0) {
                providedSettings = {
                    key: 'NGX_CACHE',
                    lifeSpan: {
                        expiry: Number.MAX_VALUE,
                        TTL: Number.MAX_VALUE
                    }
                };
            }
            this.providedSettings = providedSettings;
        }
        Object.defineProperty(CacheStaticLoader.prototype, "key", {
            get: function () {
                return this.providedSettings.key;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CacheStaticLoader.prototype, "lifeSpan", {
            get: function () {
                return this.providedSettings.lifeSpan;
            },
            enumerable: true,
            configurable: true
        });
        return CacheStaticLoader;
    }());

    var ReturnType;
    (function (ReturnType) {
        ReturnType[ReturnType["Scalar"] = 0] = "Scalar";
        ReturnType[ReturnType["Observable"] = 10] = "Observable";
        ReturnType[ReturnType["Promise"] = 20] = "Promise";
    })(ReturnType || (ReturnType = {}));

    var CACHE = new core.InjectionToken('CACHE');
    var CacheService = (function () {
        function CacheService(loader, platformId, injector) {
            this.loader = loader;
            this.platformId = platformId;
            this.injector = injector;
            CacheService.instance = this;
            this.cache = this.injector.get(CACHE);
            this.lifeSpan = loader.lifeSpan;
        }
        CacheService.getInstance = function (loader, platformId, injector) {
            return CacheService.instance;
        };
        CacheService.normalizeKey = function (key) {
            if (CacheService.validateKey(key)) {
                throw new Error('Please provide a valid key to save in the CacheService');
            }
            return "" + key;
        };
        CacheService.validateKey = function (key) {
            return !key || typeof key === 'boolean' || Number.isNaN(key);
        };
        CacheService.validateValue = function (value) {
            return value.lifeSpan.expiry && value.lifeSpan.expiry > Date.now();
        };
        Object.defineProperty(CacheService.prototype, "key", {
            get: function () {
                return this.loader.key;
            },
            enumerable: true,
            configurable: true
        });
        CacheService.prototype.has = function (key) {
            var normalized = CacheService.normalizeKey(key);
            return this.cache.keys.indexOf(normalized) !== -1;
        };
        CacheService.prototype.set = function (key, value, returnType, lifeSpan) {
            if (returnType === void 0) {
                returnType = ReturnType.Scalar;
            }
            var normalized = CacheService.normalizeKey(key);
            return this.cache.setItem(normalized, {
                data: value,
                returnType: returnType,
                lifeSpan: this.parseLifeSpan(lifeSpan ? lifeSpan : this.lifeSpan)
            });
        };
        CacheService.prototype.get = function (key) {
            var normalized = CacheService.normalizeKey(key);
            var cached = this.cache.getItem(normalized);
            if (cached) {
                if (CacheService.validateValue(cached)) {
                    return cached.data;
                }
                else {
                    this.remove(normalized);
                }
            }
            return undefined;
        };
        CacheService.prototype.getWithMetadata = function (key) {
            var normalized = CacheService.normalizeKey(key);
            var cached = this.cache.getItem(normalized);
            if (cached) {
                if (CacheService.validateValue(cached)) {
                    return cached;
                }
                else {
                    this.remove(key);
                }
            }
            return undefined;
        };
        CacheService.prototype.remove = function (key, wild) {
            if (wild === void 0) {
                wild = false;
            }
            var normalized = CacheService.normalizeKey(key);
            this.cache.removeItem(normalized, wild);
        };
        CacheService.prototype.clear = function () {
            this.cache.clear();
        };
        CacheService.prototype.dehydrate = function () {
            var _this = this;
            var keys = this.cache.keys.length ? this.cache.keys : [];
            var res = {};
            keys.forEach(function (key) {
                res[key] = _this.cache.getItem(key);
            });
            return res;
        };
        CacheService.prototype.rehydrate = function (json) {
            var _this = this;
            Object.keys(json).forEach(function (key) {
                var normalized = CacheService.normalizeKey(key);
                _this.cache.setItem(normalized, json[normalized]);
            });
        };
        CacheService.prototype.parseLifeSpan = function (lifeSpan) {
            return {
                expiry: lifeSpan.expiry || (lifeSpan.TTL ? Date.now() + lifeSpan.TTL * 1000 : this.lifeSpan.expiry),
                TTL: lifeSpan.TTL || this.lifeSpan.TTL
            };
        };
        CacheService.instance = undefined;
        CacheService.decorators = [
            { type: core.Injectable }
        ];
        CacheService.ctorParameters = function () {
            return [
                { type: CacheLoader },
                { type: undefined, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
                { type: core.Injector }
            ];
        };
        return CacheService;
    }());

    var Cache = (function () {
        function Cache() {
        }
        return Cache;
    }());

    var isPromise = function (obj) { return !!obj && typeof obj.then === 'function'; };
    var isObservable = function (obj) { return !!obj && typeof obj.subscribe === 'function'; };

    function CacheKey(target, propertyKey, index) {
        var metadataKey = "__cache_" + propertyKey + "_keys";
        Array.isArray(target[metadataKey]) ? target[metadataKey].push(index) : (target[metadataKey] = [index]);
    }
    function Cached(key) {
        return function (target, propertyKey, descriptor) {
            var method = descriptor.value;
            descriptor.value = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var cache = CacheService.getInstance();
                var metadataKey = "__cache_" + propertyKey + "_keys";
                var indices = target[metadataKey];
                var keyParts = '';
                if (Array.isArray(indices)) {
                    for (var i = 0; i < args.length; i++) {
                        if (indices.indexOf(i) !== -1) {
                            keyParts = !keyParts ? String(args[i]) : keyParts + "_" + String(args[i]);
                        }
                    }
                }
                var cacheKey = !keyParts ? key : key + "_" + keyParts;
                cacheKey = CacheService.normalizeKey(cacheKey);
                if (!cache || !cacheKey) {
                    return method.apply(this, args);
                }
                if (cache.has(cacheKey)) {
                    var cached = cache.getWithMetadata(cacheKey);
                    if (cached && cached.data) {
                        switch (cached.returnType) {
                            case ReturnType.Observable:
                                return rxjs.of(cached.data);
                            case ReturnType.Promise:
                                return Promise.resolve(cached.data);
                            default:
                                return cached.data;
                        }
                    }
                }
                var value = method.apply(this, args);
                if (isObservable(value)) {
                    return value.pipe(operators.map(function (res) {
                        cache.set(cacheKey, res, ReturnType.Observable);
                        return res;
                    }));
                }
                else if (isPromise(value)) {
                    return (value).then(function (res) {
                        cache.set(cacheKey, res, ReturnType.Promise);
                        return res;
                    });
                }
                cache.set(cacheKey, value);
                return value;
            };
            return descriptor;
        };
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var Storage = (function (_super) {
        __extends(Storage, _super);
        function Storage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Storage;
    }(events.EventEmitter));

    var STORAGE = new core.InjectionToken('STORAGE');
    function cacheFactory() {
        return new CacheStaticLoader();
    }
    function cacheServiceFactory(loader, platformId, injector) {
        return new CacheService(loader, platformId, injector);
    }
    var CacheModule = (function () {
        function CacheModule(parentModule) {
            if (parentModule) {
                throw new Error('CacheModule already loaded; import in root module only.');
            }
        }
        CacheModule.forRoot = function (configuredProvider) {
            if (configuredProvider === void 0) {
                configuredProvider = {
                    provide: CacheLoader,
                    useFactory: cacheFactory
                };
            }
            return {
                ngModule: CacheModule,
                providers: [
                    configuredProvider,
                    {
                        provide: CacheService,
                        useFactory: cacheServiceFactory,
                        deps: [CacheLoader, core.PLATFORM_ID, core.Injector]
                    }
                ]
            };
        };
        CacheModule.decorators = [
            { type: core.NgModule }
        ];
        CacheModule.ctorParameters = function () {
            return [
                { type: CacheModule, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] }
            ];
        };
        return CacheModule;
    }());

    exports.STORAGE = STORAGE;
    exports.cacheFactory = cacheFactory;
    exports.cacheServiceFactory = cacheServiceFactory;
    exports.CacheModule = CacheModule;
    exports.Cache = Cache;
    exports.CacheLoader = CacheLoader;
    exports.CacheStaticLoader = CacheStaticLoader;
    exports.CACHE = CACHE;
    exports.CacheService = CacheService;
    exports.CacheKey = CacheKey;
    exports.Cached = Cached;
    exports.Storage = Storage;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ngx-cache-core.umd.js.map