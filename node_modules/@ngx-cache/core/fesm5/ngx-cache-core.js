import { Inject, Injectable, InjectionToken, Injector, PLATFORM_ID, NgModule, Optional, SkipSelf } from '@angular/core';
import { of } from 'rxjs';
import { map } from 'rxjs/operators';
import { __extends } from 'tslib';
import { EventEmitter } from 'events';

var CacheLoader = (function () {
    function CacheLoader() {
    }
    return CacheLoader;
}());
var CacheStaticLoader = (function () {
    function CacheStaticLoader(providedSettings) {
        if (providedSettings === void 0) { providedSettings = {
            key: 'NGX_CACHE',
            lifeSpan: {
                expiry: Number.MAX_VALUE,
                TTL: Number.MAX_VALUE
            }
        }; }
        this.providedSettings = providedSettings;
    }
    Object.defineProperty(CacheStaticLoader.prototype, "key", {
        get: function () {
            return this.providedSettings.key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CacheStaticLoader.prototype, "lifeSpan", {
        get: function () {
            return this.providedSettings.lifeSpan;
        },
        enumerable: true,
        configurable: true
    });
    return CacheStaticLoader;
}());

var ReturnType;
(function (ReturnType) {
    ReturnType[ReturnType["Scalar"] = 0] = "Scalar";
    ReturnType[ReturnType["Observable"] = 10] = "Observable";
    ReturnType[ReturnType["Promise"] = 20] = "Promise";
})(ReturnType || (ReturnType = {}));

var CACHE = new InjectionToken('CACHE');
var CacheService = (function () {
    function CacheService(loader, platformId, injector) {
        this.loader = loader;
        this.platformId = platformId;
        this.injector = injector;
        CacheService.instance = this;
        this.cache = this.injector.get(CACHE);
        this.lifeSpan = loader.lifeSpan;
    }
    CacheService.getInstance = function (loader, platformId, injector) {
        return CacheService.instance;
    };
    CacheService.normalizeKey = function (key) {
        if (CacheService.validateKey(key)) {
            throw new Error('Please provide a valid key to save in the CacheService');
        }
        return "" + key;
    };
    CacheService.validateKey = function (key) {
        return !key || typeof key === 'boolean' || Number.isNaN(key);
    };
    CacheService.validateValue = function (value) {
        return value.lifeSpan.expiry && value.lifeSpan.expiry > Date.now();
    };
    Object.defineProperty(CacheService.prototype, "key", {
        get: function () {
            return this.loader.key;
        },
        enumerable: true,
        configurable: true
    });
    CacheService.prototype.has = function (key) {
        var normalized = CacheService.normalizeKey(key);
        return this.cache.keys.indexOf(normalized) !== -1;
    };
    CacheService.prototype.set = function (key, value, returnType, lifeSpan) {
        if (returnType === void 0) { returnType = ReturnType.Scalar; }
        var normalized = CacheService.normalizeKey(key);
        return this.cache.setItem(normalized, {
            data: value,
            returnType: returnType,
            lifeSpan: this.parseLifeSpan(lifeSpan ? lifeSpan : this.lifeSpan)
        });
    };
    CacheService.prototype.get = function (key) {
        var normalized = CacheService.normalizeKey(key);
        var cached = this.cache.getItem(normalized);
        if (cached) {
            if (CacheService.validateValue(cached)) {
                return cached.data;
            }
            else {
                this.remove(normalized);
            }
        }
        return undefined;
    };
    CacheService.prototype.getWithMetadata = function (key) {
        var normalized = CacheService.normalizeKey(key);
        var cached = this.cache.getItem(normalized);
        if (cached) {
            if (CacheService.validateValue(cached)) {
                return cached;
            }
            else {
                this.remove(key);
            }
        }
        return undefined;
    };
    CacheService.prototype.remove = function (key, wild) {
        if (wild === void 0) { wild = false; }
        var normalized = CacheService.normalizeKey(key);
        this.cache.removeItem(normalized, wild);
    };
    CacheService.prototype.clear = function () {
        this.cache.clear();
    };
    CacheService.prototype.dehydrate = function () {
        var _this = this;
        var keys = this.cache.keys.length ? this.cache.keys : [];
        var res = {};
        keys.forEach(function (key) {
            res[key] = _this.cache.getItem(key);
        });
        return res;
    };
    CacheService.prototype.rehydrate = function (json) {
        var _this = this;
        Object.keys(json).forEach(function (key) {
            var normalized = CacheService.normalizeKey(key);
            _this.cache.setItem(normalized, json[normalized]);
        });
    };
    CacheService.prototype.parseLifeSpan = function (lifeSpan) {
        return {
            expiry: lifeSpan.expiry || (lifeSpan.TTL ? Date.now() + lifeSpan.TTL * 1000 : this.lifeSpan.expiry),
            TTL: lifeSpan.TTL || this.lifeSpan.TTL
        };
    };
    CacheService.instance = undefined;
    CacheService.decorators = [
        { type: Injectable }
    ];
    CacheService.ctorParameters = function () { return [
        { type: CacheLoader },
        { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: Injector }
    ]; };
    return CacheService;
}());

var Cache = (function () {
    function Cache() {
    }
    return Cache;
}());

var isPromise = function (obj) { return !!obj && typeof obj.then === 'function'; };
var isObservable = function (obj) { return !!obj && typeof obj.subscribe === 'function'; };

function CacheKey(target, propertyKey, index) {
    var metadataKey = "__cache_" + propertyKey + "_keys";
    Array.isArray(target[metadataKey]) ? target[metadataKey].push(index) : (target[metadataKey] = [index]);
}
function Cached(key) {
    return function (target, propertyKey, descriptor) {
        var method = descriptor.value;
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var cache = CacheService.getInstance();
            var metadataKey = "__cache_" + propertyKey + "_keys";
            var indices = target[metadataKey];
            var keyParts = '';
            if (Array.isArray(indices)) {
                for (var i = 0; i < args.length; i++) {
                    if (indices.indexOf(i) !== -1) {
                        keyParts = !keyParts ? String(args[i]) : keyParts + "_" + String(args[i]);
                    }
                }
            }
            var cacheKey = !keyParts ? key : key + "_" + keyParts;
            cacheKey = CacheService.normalizeKey(cacheKey);
            if (!cache || !cacheKey) {
                return method.apply(this, args);
            }
            if (cache.has(cacheKey)) {
                var cached = cache.getWithMetadata(cacheKey);
                if (cached && cached.data) {
                    switch (cached.returnType) {
                        case ReturnType.Observable:
                            return of(cached.data);
                        case ReturnType.Promise:
                            return Promise.resolve(cached.data);
                        default:
                            return cached.data;
                    }
                }
            }
            var value = method.apply(this, args);
            if (isObservable(value)) {
                return value.pipe(map(function (res) {
                    cache.set(cacheKey, res, ReturnType.Observable);
                    return res;
                }));
            }
            else if (isPromise(value)) {
                return (value).then(function (res) {
                    cache.set(cacheKey, res, ReturnType.Promise);
                    return res;
                });
            }
            cache.set(cacheKey, value);
            return value;
        };
        return descriptor;
    };
}

var Storage = (function (_super) {
    __extends(Storage, _super);
    function Storage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Storage;
}(EventEmitter));

var STORAGE = new InjectionToken('STORAGE');
function cacheFactory() {
    return new CacheStaticLoader();
}
function cacheServiceFactory(loader, platformId, injector) {
    return new CacheService(loader, platformId, injector);
}
var CacheModule = (function () {
    function CacheModule(parentModule) {
        if (parentModule) {
            throw new Error('CacheModule already loaded; import in root module only.');
        }
    }
    CacheModule.forRoot = function (configuredProvider) {
        if (configuredProvider === void 0) { configuredProvider = {
            provide: CacheLoader,
            useFactory: cacheFactory
        }; }
        return {
            ngModule: CacheModule,
            providers: [
                configuredProvider,
                {
                    provide: CacheService,
                    useFactory: cacheServiceFactory,
                    deps: [CacheLoader, PLATFORM_ID, Injector]
                }
            ]
        };
    };
    CacheModule.decorators = [
        { type: NgModule }
    ];
    CacheModule.ctorParameters = function () { return [
        { type: CacheModule, decorators: [{ type: Optional }, { type: SkipSelf }] }
    ]; };
    return CacheModule;
}());

export { STORAGE, cacheFactory, cacheServiceFactory, CacheModule, Cache, CacheLoader, CacheStaticLoader, CACHE, CacheService, CacheKey, Cached, Storage };

//# sourceMappingURL=ngx-cache-core.js.map